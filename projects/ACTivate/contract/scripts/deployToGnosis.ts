import { ethers } from "hardhat";
import * as fs from "fs";
import * as path from "path";

async function main() {
  console.log("ğŸš€ Deploying DataContract to Gnosis Chain...");
  console.log("==================================================");

  // Get the contract factory
  const DataContract = await ethers.getContractFactory("DataContract");

  // Get the deployer account
  const [deployer] = await ethers.getSigners();
  console.log("Deploying with account:", deployer.address);

  // Check balance
  const balance = await ethers.provider.getBalance(deployer.address);
  console.log("Account balance:", ethers.formatEther(balance), "xDAI");

  if (balance === 0n) {
    console.error("âŒ Insufficient balance! Please fund your account with xDAI.");
    console.log("Get xDAI from:");
    console.log("- Bridge ETH to xDAI: https://bridge.gnosischain.com/");
    console.log("- Gnosis Chain Faucet: https://gnosisfaucet.com/");
    process.exit(1);
  }

  // Deploy the contract
  console.log("\nğŸ“‹ Deploying contract...");
  const contract = await DataContract.deploy();
  
  // Wait for deployment transaction to be mined
  console.log("â³ Waiting for deployment transaction...");
  await contract.waitForDeployment();
  
  const contractAddress = await contract.getAddress();
  console.log("âœ… DataContract deployed to:", contractAddress);

  // Get deployment transaction details
  const deploymentTx = contract.deploymentTransaction();
  if (deploymentTx) {
    console.log("Transaction hash:", deploymentTx.hash);
    console.log("Block number:", deploymentTx.blockNumber);
    console.log("Gas used:", deploymentTx.gasLimit?.toString());
  }

  // Verify the contract is deployed correctly
  console.log("\nğŸ” Verifying deployment...");
  console.log("Contract deployed successfully - public access enabled");
  console.log("Anyone can call sendDataToTarget function");

  // Create deployments directory if it doesn't exist
  const deploymentsDir = path.join(__dirname, "..", "deployments");
  if (!fs.existsSync(deploymentsDir)) {
    fs.mkdirSync(deploymentsDir, { recursive: true });
  }

  // Save deployment information
  const deploymentInfo = {
    network: "gnosis",
    chainId: 100,
    contractName: "DataContract",
    contractAddress: contractAddress,
    deployerAddress: deployer.address,
    transactionHash: deploymentTx?.hash,
    blockNumber: deploymentTx?.blockNumber,
    gasUsed: deploymentTx?.gasLimit?.toString(),
    timestamp: new Date().toISOString(),
    rpcUrl: process.env.GNOSIS_RPC_URL || "https://rpc.gnosischain.com"
  };

  // Write deployment JSON
  const deploymentFile = path.join(deploymentsDir, "gnosis-deployment.json");
  try {
    fs.writeFileSync(deploymentFile, JSON.stringify(deploymentInfo, null, 2));
    console.log("âœ… Deployment info saved to:", deploymentFile);
  } catch (error) {
    console.error("âŒ Failed to save deployment info:", error);
  }

  // Generate environment variables file
  const envContent = `# Gnosis Chain Deployment Configuration
# Generated on ${new Date().toISOString()}

GNOSIS_CONTRACT_ADDRESS=${contractAddress}
GNOSIS_DEPLOYER_ADDRESS=${deployer.address}
GNOSIS_CHAIN_ID=100
GNOSIS_RPC_URL=${process.env.GNOSIS_RPC_URL || "https://rpc.gnosischain.com"}
GNOSIS_BLOCK_EXPLORER=https://gnosisscan.io
`;

  const envFile = path.join(deploymentsDir, "gnosis.env");
  try {
    fs.writeFileSync(envFile, envContent);
    console.log("âœ… Environment variables saved to:", envFile);
  } catch (error) {
    console.error("âŒ Failed to save environment file:", error);
  }

  // Generate Go constants file
  const goContent = `// Code generated by Gnosis deployment script. DO NOT EDIT.
// Generated on ${new Date().toISOString()}

package main

const (
	// Gnosis Chain Configuration
	GnosisChainID      = 100
	GnosisRPCURL       = "${process.env.GNOSIS_RPC_URL || "https://rpc.gnosischain.com"}"
	GnosisExplorerURL  = "https://gnosisscan.io"
	
	// Contract Deployment Info
	GnosisContractAddress = "${contractAddress}"
	GnosisDeployerAddress = "${deployer.address}"
	GnosisDeploymentBlock = ${deploymentTx?.blockNumber || 0}
)
`;

  const goFile = path.join(deploymentsDir, "gnosis-constants.go");
  try {
    fs.writeFileSync(goFile, goContent);
    console.log("âœ… Go constants saved to:", goFile);
  } catch (error) {
    console.error("âŒ Failed to save Go constants:", error);
  }

  console.log("\nğŸ‰ Deployment completed successfully!");
  console.log("=======================================");
  console.log("Contract Address:", contractAddress);
  console.log("Network: Gnosis Chain (Chain ID: 100)");
  console.log("Explorer:", `https://gnosisscan.io/address/${contractAddress}`);
  console.log("Public Access: Enabled (anyone can call functions)");
  
  console.log("\nğŸ“‹ Next steps:");
  console.log("1. Verify contract on Gnosisscan (optional)");
  console.log("2. Test contract interaction with the Go examples");
  console.log("3. Fund more accounts if needed for testing");
  
  console.log("\nğŸ”— Useful links:");
  console.log("- Gnosis Chain Bridge: https://bridge.gnosischain.com/");
  console.log("- Gnosisscan Explorer: https://gnosisscan.io/");
  console.log("- Gnosis Chain Docs: https://docs.gnosischain.com/");
}

// We recommend this pattern to be able to use async/await everywhere
// and properly handle errors.
main().catch((error) => {
  console.error("âŒ Deployment failed:", error);
  process.exitCode = 1;
});
